/**
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import java.util.Iterator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.xtext.example.mydsl.mml.AllVariables;
import org.xtext.example.mydsl.mml.CSVParsingConfiguration;
import org.xtext.example.mydsl.mml.CrossValidation;
import org.xtext.example.mydsl.mml.DT;
import org.xtext.example.mydsl.mml.DataInput;
import org.xtext.example.mydsl.mml.FormulaItem;
import org.xtext.example.mydsl.mml.FrameworkLang;
import org.xtext.example.mydsl.mml.MLAlgorithm;
import org.xtext.example.mydsl.mml.MLChoiceAlgorithm;
import org.xtext.example.mydsl.mml.PredictorVariables;
import org.xtext.example.mydsl.mml.RFormula;
import org.xtext.example.mydsl.mml.SVR;
import org.xtext.example.mydsl.mml.StratificationMethod;
import org.xtext.example.mydsl.mml.TrainingTest;
import org.xtext.example.mydsl.mml.Validation;
import org.xtext.example.mydsl.mml.ValidationMetric;
import org.xtext.example.mydsl.mml.XFormula;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class MmlGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final Iterator<DataInput> dataInputIterator = Iterators.<DataInput>filter(resource.getAllContents(), DataInput.class);
    final DataInput dataInput = dataInputIterator.next();
    final String fileLocation = dataInput.getFilelocation();
    final Iterator<MLChoiceAlgorithm> mlAlgoIterator = Iterators.<MLChoiceAlgorithm>filter(resource.getAllContents(), MLChoiceAlgorithm.class);
    final MLChoiceAlgorithm mlchoicealgo = mlAlgoIterator.next();
    final Iterator<Validation> validationIterator = Iterators.<Validation>filter(resource.getAllContents(), Validation.class);
    final Validation validation = validationIterator.next();
    final Iterator<RFormula> formuleIterator = Iterators.<RFormula>filter(resource.getAllContents(), RFormula.class);
    RFormula _xifexpression = null;
    boolean _hasNext = formuleIterator.hasNext();
    if (_hasNext) {
      _xifexpression = formuleIterator.next();
    }
    final RFormula formule = _xifexpression;
    final String DEFAULT_COLUMN_SEPARATOR = ",";
    String csv_separator = DEFAULT_COLUMN_SEPARATOR;
    final CSVParsingConfiguration parsingInstruction = dataInput.getParsingInstruction();
    if ((parsingInstruction != null)) {
      csv_separator = parsingInstruction.getSep().toString();
    }
    final FrameworkLang framework = mlchoicealgo.getFramework();
    String code = "";
    String type = "";
    int _value = framework.getValue();
    switch (_value) {
      case FrameworkLang.JAVA_WEKA_VALUE:
        code = this.compileWeka(formule, fileLocation, mlchoicealgo, validation, csv_separator);
        break;
      case FrameworkLang.SCIKIT_VALUE:
        code = this.compileScikit(formule, fileLocation, mlchoicealgo, validation, csv_separator);
        break;
      case FrameworkLang.R_VALUE:
        code = this.compileR(formule, fileLocation, mlchoicealgo, validation, csv_separator);
        break;
      case FrameworkLang.XG_BOOST_VALUE:
        code = this.compileXG(formule, fileLocation, mlchoicealgo, validation, csv_separator);
        break;
      default:
        code = "";
        break;
    }
    int _value_1 = framework.getValue();
    switch (_value_1) {
      case FrameworkLang.JAVA_WEKA_VALUE:
        type = "java";
        break;
      case FrameworkLang.SCIKIT_VALUE:
        type = "py";
        break;
      case FrameworkLang.R_VALUE:
        type = "r";
        break;
      case FrameworkLang.XG_BOOST_VALUE:
        type = "py";
        break;
      default:
        type = "";
        break;
    }
    fsa.generateFile(
      ("test." + type), code);
  }
  
  public String compileWeka(final RFormula formule, final String fileLocation, final MLChoiceAlgorithm mlchoicealgo, final Validation validation, final String csv_separator) {
    return null;
  }
  
  public String compileXG(final RFormula formule, final String fileLocation, final MLChoiceAlgorithm mlchoicealgo, final Validation validation, final String csv_separator) {
    return null;
  }
  
  public String compileR(final RFormula formule, final String fileLocation, final MLChoiceAlgorithm mlchoicealgo, final Validation validation, final String csv_separator) {
    String rImport = "library(data.table)\n";
    String csvSplit = "";
    if ((formule != null)) {
      XFormula xformule = formule.getPredictors();
      FormulaItem formuleItem = formule.getPredictive();
      String items = "";
      if ((xformule instanceof PredictorVariables)) {
        EList<FormulaItem> predictorItems = ((PredictorVariables)xformule).getVars();
        StringBuilder sb = new StringBuilder();
        if (((predictorItems != null) && (!predictorItems.isEmpty()))) {
          String _colName = predictorItems.get(0).getColName();
          boolean _tripleNotEquals = (_colName != null);
          if (_tripleNotEquals) {
            for (final FormulaItem item : predictorItems) {
              {
                FormulaItem _get = predictorItems.get(0);
                boolean _notEquals = (!Objects.equal(_get, item));
                if (_notEquals) {
                  sb.append(",");
                }
                sb.append(this.mkValueInDoubleQuote(item.getColName()));
              }
            }
          } else {
            for (final FormulaItem item_1 : predictorItems) {
              {
                FormulaItem _get = predictorItems.get(0);
                boolean _notEquals = (!Objects.equal(_get, item_1));
                if (_notEquals) {
                  sb.append(",");
                }
                sb.append(item_1.getColumn());
              }
            }
          }
        }
        items = sb.toString();
        String _csvSplit = csvSplit;
        String _mkValueInDoubleQuote = this.mkValueInDoubleQuote(fileLocation);
        String _plus = ("X <- read.csv(file=" + _mkValueInDoubleQuote);
        String _plus_1 = (_plus + ", select=c(");
        String _plus_2 = (_plus_1 + items);
        String _plus_3 = (_plus_2 + ") ,header=TRUE, sep=");
        String _mkValueInDoubleQuote_1 = this.mkValueInDoubleQuote(csv_separator);
        String _plus_4 = (_plus_3 + _mkValueInDoubleQuote_1);
        String _plus_5 = (_plus_4 + ")\n");
        csvSplit = (_csvSplit + _plus_5);
        String _csvSplit_1 = csvSplit;
        String _mkValueInDoubleQuote_2 = this.mkValueInDoubleQuote(fileLocation);
        String _plus_6 = ("y <- read.csv(file=" + _mkValueInDoubleQuote_2);
        String _plus_7 = (_plus_6 + ", select=c(");
        int _column = formuleItem.getColumn();
        String _plus_8 = (_plus_7 + Integer.valueOf(_column));
        String _plus_9 = (_plus_8 + ") ,header=TRUE, sep=");
        String _mkValueInDoubleQuote_3 = this.mkValueInDoubleQuote(csv_separator);
        String _plus_10 = (_plus_9 + _mkValueInDoubleQuote_3);
        String _plus_11 = (_plus_10 + ")\\n");
        csvSplit = (_csvSplit_1 + _plus_11);
      } else {
        if ((xformule instanceof AllVariables)) {
          String _csvSplit_2 = csvSplit;
          String _mkValueInDoubleQuote_4 = this.mkValueInDoubleQuote(fileLocation);
          String _plus_12 = ("myFile <- read.csv(file=" + _mkValueInDoubleQuote_4);
          String _plus_13 = (_plus_12 + ",header=TRUE, sep=");
          String _mkValueInDoubleQuote_5 = this.mkValueInDoubleQuote(csv_separator);
          String _plus_14 = (_plus_13 + _mkValueInDoubleQuote_5);
          String _plus_15 = (_plus_14 + ")\n");
          csvSplit = (_csvSplit_2 + _plus_15);
          String _csvSplit_3 = csvSplit;
          csvSplit = (_csvSplit_3 + "h<-head(myFile)\nlastcol <- tail(h, n=1)\n");
          String _csvSplit_4 = csvSplit;
          String _mkValueInDoubleQuote_6 = this.mkValueInDoubleQuote(fileLocation);
          String _plus_16 = ("X <- read.csv(file=" + _mkValueInDoubleQuote_6);
          String _plus_17 = (_plus_16 + ", drop=c(lastcol) ,header=TRUE, sep=");
          String _mkValueInDoubleQuote_7 = this.mkValueInDoubleQuote(csv_separator);
          String _plus_18 = (_plus_17 + _mkValueInDoubleQuote_7);
          String _plus_19 = (_plus_18 + ")\n");
          csvSplit = (_csvSplit_4 + _plus_19);
          String _csvSplit_5 = csvSplit;
          String _mkValueInDoubleQuote_8 = this.mkValueInDoubleQuote(fileLocation);
          String _plus_20 = ("y <- read.csv(file=" + _mkValueInDoubleQuote_8);
          String _plus_21 = (_plus_20 + ", select=c(lastcol) ,header=TRUE, sep=");
          String _mkValueInDoubleQuote_9 = this.mkValueInDoubleQuote(csv_separator);
          String _plus_22 = (_plus_21 + _mkValueInDoubleQuote_9);
          String _plus_23 = (_plus_22 + ")\n");
          csvSplit = (_csvSplit_5 + _plus_23);
        }
      }
    } else {
      String _csvSplit_6 = csvSplit;
      String _mkValueInDoubleQuote_10 = this.mkValueInDoubleQuote(fileLocation);
      String _plus_24 = ("myFile <- read.csv(file=" + _mkValueInDoubleQuote_10);
      String _plus_25 = (_plus_24 + ",header=TRUE, sep=");
      String _mkValueInDoubleQuote_11 = this.mkValueInDoubleQuote(csv_separator);
      String _plus_26 = (_plus_25 + _mkValueInDoubleQuote_11);
      String _plus_27 = (_plus_26 + ")\n");
      csvSplit = (_csvSplit_6 + _plus_27);
      String _csvSplit_7 = csvSplit;
      csvSplit = (_csvSplit_7 + "h<-head(myFile)\nlastcol <- tail(h, n=1)\n");
      String _csvSplit_8 = csvSplit;
      String _mkValueInDoubleQuote_12 = this.mkValueInDoubleQuote(fileLocation);
      String _plus_28 = ("X <- read.csv(file=" + _mkValueInDoubleQuote_12);
      String _plus_29 = (_plus_28 + ", drop=c(lastcol) ,header=TRUE, sep=");
      String _mkValueInDoubleQuote_13 = this.mkValueInDoubleQuote(csv_separator);
      String _plus_30 = (_plus_29 + _mkValueInDoubleQuote_13);
      String _plus_31 = (_plus_30 + ")\n");
      csvSplit = (_csvSplit_8 + _plus_31);
      String _csvSplit_9 = csvSplit;
      String _mkValueInDoubleQuote_14 = this.mkValueInDoubleQuote(fileLocation);
      String _plus_32 = ("y <- read.csv(file=" + _mkValueInDoubleQuote_14);
      String _plus_33 = (_plus_32 + ", select=c(lastcol) ,header=TRUE, sep=");
      String _mkValueInDoubleQuote_15 = this.mkValueInDoubleQuote(csv_separator);
      String _plus_34 = (_plus_33 + _mkValueInDoubleQuote_15);
      String _plus_35 = (_plus_34 + ")\n");
      csvSplit = (_csvSplit_9 + _plus_35);
    }
    final MLAlgorithm algo = mlchoicealgo.getAlgorithm();
    String algoDeclaration = "";
    if ((algo instanceof SVR)) {
    } else {
      if ((algo instanceof DT)) {
        String _rImport = rImport;
        rImport = (_rImport + "library(rpart)\n");
        algoDeclaration = "fit <- rpart(survived~., data= data_train, method=\'class\')\n";
      }
    }
    final StratificationMethod stratMethod = validation.getStratification();
    final EList<ValidationMetric> validMetrics = validation.getMetric();
    final int number = stratMethod.getNumber();
    String validationPrint = "";
    String _validationPrint = validationPrint;
    validationPrint = (_validationPrint + (("test_size = " + Integer.valueOf(number)) + "\n"));
    String _validationPrint_1 = validationPrint;
    validationPrint = (_validationPrint_1 + "n_row = nrow(X)\n");
    String _validationPrint_2 = validationPrint;
    validationPrint = (_validationPrint_2 + "total_row = test_size * n_row\n");
    if ((stratMethod instanceof CrossValidation)) {
    } else {
      if ((stratMethod instanceof TrainingTest)) {
        String _validationPrint_3 = validationPrint;
        validationPrint = (_validationPrint_3 + "X_train <- 1:total_row\n");
        String _validationPrint_4 = validationPrint;
        validationPrint = (_validationPrint_4 + (("X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=" + Integer.valueOf(number)) + ")"));
      }
    }
    String _validationPrint_5 = validationPrint;
    validationPrint = (_validationPrint_5 + "\n");
    String metrics = "";
    String metricsResult = "";
    for (int i = 0; (i < validMetrics.size()); i++) {
      {
        String metric = "";
        String _metricsResult = metricsResult;
        metricsResult = (_metricsResult + (("print(accuracy" + Integer.valueOf(i)) + ")\n"));
        String _metrics = metrics;
        metrics = (_metrics + (metric + "\n"));
      }
    }
    final String pandasCode = (((((rImport + csvSplit) + algoDeclaration) + validationPrint) + metrics) + metricsResult);
    return pandasCode;
  }
  
  public String compileScikit(final RFormula formule, final String fileLocation, final MLChoiceAlgorithm mlchoicealgo, final Validation validation, final String csv_separator) {
    String pythonImport = "import pandas as pd\n";
    String _mkValueInSingleQuote = this.mkValueInSingleQuote(fileLocation);
    String _plus = ("df = pd.read_csv(" + _mkValueInSingleQuote);
    String _plus_1 = (_plus + ", sep=");
    String _mkValueInSingleQuote_1 = this.mkValueInSingleQuote(csv_separator);
    String _plus_2 = (_plus_1 + _mkValueInSingleQuote_1);
    String csvReading = (_plus_2 + ")\n");
    String csvSplit = "";
    if ((formule != null)) {
      XFormula xformule = formule.getPredictors();
      FormulaItem formuleItem = formule.getPredictive();
      String items = "";
      if ((xformule instanceof PredictorVariables)) {
        EList<FormulaItem> predictorItems = ((PredictorVariables)xformule).getVars();
        StringBuilder sb = new StringBuilder();
        if (((predictorItems != null) && (!predictorItems.isEmpty()))) {
          String _colName = predictorItems.get(0).getColName();
          boolean _tripleNotEquals = (_colName != null);
          if (_tripleNotEquals) {
            for (final FormulaItem item : predictorItems) {
              {
                FormulaItem _get = predictorItems.get(0);
                boolean _notEquals = (!Objects.equal(_get, item));
                if (_notEquals) {
                  sb.append(",");
                }
                String _colName_1 = item.getColName();
                String _plus_3 = ("\'" + _colName_1);
                String _plus_4 = (_plus_3 + "\'");
                sb.append(_plus_4);
              }
            }
          } else {
            for (final FormulaItem item_1 : predictorItems) {
              {
                FormulaItem _get = predictorItems.get(0);
                boolean _notEquals = (!Objects.equal(_get, item_1));
                if (_notEquals) {
                  sb.append(",");
                }
                sb.append(item_1.getColumn());
              }
            }
          }
        }
        items = sb.toString();
        String _csvSplit = csvSplit;
        csvSplit = (_csvSplit + (("X = df[df.columns.difference([" + items) + "])]\n"));
        String _csvSplit_1 = csvSplit;
        int _column = formuleItem.getColumn();
        String _plus_3 = ("y = df[columns = [df.columns[" + Integer.valueOf(_column));
        String _plus_4 = (_plus_3 + "]]]\n");
        csvSplit = (_csvSplit_1 + _plus_4);
      } else {
        if ((xformule instanceof AllVariables)) {
          String _csvSplit_2 = csvSplit;
          csvSplit = (_csvSplit_2 + "X = df.drop(columns = [df.columns[-1]])\n");
          String _csvSplit_3 = csvSplit;
          csvSplit = (_csvSplit_3 + "y = df[columns = [df.columns[-1]]]\n");
        }
      }
    } else {
      String _csvSplit_4 = csvSplit;
      csvSplit = (_csvSplit_4 + "X = df.drop(columns = [df.columns[-1]])\n");
      String _csvSplit_5 = csvSplit;
      csvSplit = (_csvSplit_5 + "y = df[columns = [df.columns[-1]]]\n");
    }
    MLAlgorithm algo = mlchoicealgo.getAlgorithm();
    String algoDeclaration = "";
    if ((algo instanceof SVR)) {
    } else {
      if ((algo instanceof DT)) {
        String _pythonImport = pythonImport;
        pythonImport = (_pythonImport + "from sklearn import tree\n");
        algoDeclaration = "clf = tree.DecisionTreeRegressor()\n";
      }
    }
    StratificationMethod stratMethod = validation.getStratification();
    EList<ValidationMetric> validMetrics = validation.getMetric();
    int number = stratMethod.getNumber();
    String validationPrint = "";
    String _validationPrint = validationPrint;
    validationPrint = (_validationPrint + (("test_size = " + Integer.valueOf(number)) + "\n"));
    if ((stratMethod instanceof CrossValidation)) {
    } else {
      if ((stratMethod instanceof TrainingTest)) {
        String _pythonImport_1 = pythonImport;
        pythonImport = (_pythonImport_1 + "from sklearn.model_selection import train_test_split\n");
        String _validationPrint_1 = validationPrint;
        validationPrint = (_validationPrint_1 + (("X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=" + Integer.valueOf(number)) + ")"));
      }
    }
    String _validationPrint_2 = validationPrint;
    validationPrint = (_validationPrint_2 + "\n");
    String metrics = "";
    String metricsResult = "";
    for (int i = 0; (i < validMetrics.size()); i++) {
      {
        String metric = "";
        final String metricName = validMetrics.get(i).name();
        boolean _equals = Objects.equal(metricName, "MSE");
        if (_equals) {
          String _pythonImport_2 = pythonImport;
          pythonImport = (_pythonImport_2 + "from sklearn.metrics import mean_squared_error\n");
          String _metric = metric;
          metric = (_metric + (("accuracy" + Integer.valueOf(i)) + "=mean_squared_error(y_test, clf.predict(X_test))"));
        } else {
          boolean _equals_1 = Objects.equal(metricName, "MAE");
          if (_equals_1) {
            String _pythonImport_3 = pythonImport;
            pythonImport = (_pythonImport_3 + "from sklearn.metrics import mean_absolute_error\n");
            String _metric_1 = metric;
            metric = (_metric_1 + (("accuracy" + Integer.valueOf(i)) + "=mean_absolute_error(y_test, clf.predict(X_test))"));
          } else {
            boolean _equals_2 = Objects.equal(metricName, "MAPE");
            if (_equals_2) {
              String _pythonImport_4 = pythonImport;
              pythonImport = (_pythonImport_4 + "from sklearn.utils import check_arrays\n");
              String _metric_2 = metric;
              metric = (_metric_2 + "y_test, y_pred = check_arrays(y_test, clf.predict(X_test))");
              String _metric_3 = metric;
              metric = (_metric_3 + (("accuracy" + Integer.valueOf(i)) + "=np.mean(np.abs((y_test - y_pred) / y_test)) * 100"));
            }
          }
        }
        String _metricsResult = metricsResult;
        metricsResult = (_metricsResult + (("print(accuracy" + Integer.valueOf(i)) + ")\n"));
        String _metrics = metrics;
        metrics = (_metrics + (metric + "\n"));
      }
    }
    String pandasCode = ((((((pythonImport + csvReading) + csvSplit) + algoDeclaration) + validationPrint) + metrics) + metricsResult);
    return pandasCode;
  }
  
  public String mkValueInSingleQuote(final String value) {
    return (("\'" + value) + "\'");
  }
  
  public String mkValueInDoubleQuote(final String value) {
    return (("\"" + value) + "\"");
  }
}
